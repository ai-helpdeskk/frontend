# .github/workflows/frontend-ci.yml
name: Frontend - CI

on:
  push:
    branches: [ main, develop ]
    paths:
      - 'frontend/**'
  pull_request:
    branches: [ main ]
    paths:
      - 'frontend/**'
  workflow_dispatch:

env:
  SERVICE_NAME: frontend
  IMAGE_NAME: samitsinghhh/frontend
  NODE_VERSION: '18'

defaults:
  run:
    working-directory: frontend

jobs:
  # Lint and Code Quality
  lint:
    name: Code Quality & Linting
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          if [ ! -f "package-lock.json" ]; then
            echo "ðŸ“¦ Creating package-lock.json..."
            npm install
          else
            npm ci
          fi

      - name: Install development dependencies
        run: |
          npm install --save-dev eslint prettier @eslint/js

      - name: Code formatting check (Prettier)
        run: |
          if npm list prettier > /dev/null 2>&1; then
            npx prettier --check src/ || echo "âš ï¸ Prettier formatting issues found"
          else
            echo "â„¹ï¸ Prettier not available, skipping format check"
          fi
        continue-on-error: true

      - name: Lint with ESLint
        run: |
          if npm list eslint > /dev/null 2>&1; then
            npx eslint src/ --ext .js,.jsx --max-warnings 10 || echo "âš ï¸ ESLint issues found"
          else
            echo "â„¹ï¸ ESLint not available, skipping lint check"
          fi
        continue-on-error: true

      - name: Check for unused dependencies
        run: |
          npm ls --depth=0 || echo "âš ï¸ Some dependency issues found"
        continue-on-error: true

  # Security Scanning
  security:
    name: Security Scan
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}

      - name: Install dependencies
        run: |
          if [ ! -f "package-lock.json" ]; then
            npm install
          else
            npm ci
          fi

      - name: Run npm audit
        run: |
          npm audit --audit-level=moderate || echo "âš ï¸ npm audit found issues"
          npm audit --json > audit-report.json || true
        continue-on-error: true

      - name: Upload security reports
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: security-reports-${{ env.SERVICE_NAME }}
          path: |
            frontend/audit-report.json

  # Unit Tests
  test:
    name: Unit Tests
    runs-on: ubuntu-latest
    strategy:
      matrix:
        node-version: ['16', '18', '20']
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js ${{ matrix.node-version }}
        uses: actions/setup-node@v4
        with:
          node-version: ${{ matrix.node-version }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          if [ ! -f "package-lock.json" ]; then
            npm install
          else
            npm ci
          fi

      - name: Install testing dependencies
        run: |
          npm install --save-dev @testing-library/react @testing-library/jest-dom @testing-library/user-event

      - name: Create comprehensive test file
        run: |
          cat > src/App.test.js << 'EOF'
          import { render, screen, fireEvent, waitFor } from '@testing-library/react';
          import '@testing-library/jest-dom';
          import App from './App';

          // Mock axios
          jest.mock('axios', () => ({
            get: jest.fn(),
            post: jest.fn(),
            delete: jest.fn(),
          }));

          const axios = require('axios');

          describe('App Component', () => {
            beforeEach(() => {
              jest.clearAllMocks();
              // Mock successful API responses
              axios.get.mockResolvedValue({ 
                data: { history: [], files: [] } 
              });
              axios.post.mockResolvedValue({
                data: { response: 'Test response', session_id: 'test-session', model_used: 'test-model' }
              });
            });

            test('renders main app header', () => {
              render(<App />);
              const headerElement = screen.getByText(/AI Chat/i);
              expect(headerElement).toBeInTheDocument();
            });

            test('app component mounts without crashing', () => {
              render(<App />);
              expect(screen.getByRole('textbox')).toBeInTheDocument();
            });

            test('displays session information', () => {
              render(<App />);
              expect(screen.getByText(/Session:/)).toBeInTheDocument();
            });

            test('has clear chat button', () => {
              render(<App />);
              const clearButton = screen.getByText(/Clear Chat/i);
              expect(clearButton).toBeInTheDocument();
            });

            test('has file upload area', () => {
              render(<App />);
              const dropZone = screen.getByText(/Drop files here/i);
              expect(dropZone).toBeInTheDocument();
            });

            test('has message input and send button', () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              
              expect(messageInput).toBeInTheDocument();
              expect(sendButton).toBeInTheDocument();
            });

            test('can type in message input', () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              
              fireEvent.change(messageInput, { target: { value: 'Test message' } });
              expect(messageInput.value).toBe('Test message');
            });

            test('send button is initially enabled for valid input', () => {
              render(<App />);
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              
              // Initially enabled (assuming no loading state)
              expect(sendButton).not.toBeDisabled();
            });

            test('handles form submission with message', async () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              
              fireEvent.change(messageInput, { target: { value: 'Test message' } });
              fireEvent.click(sendButton);
              
              await waitFor(() => {
                expect(axios.post).toHaveBeenCalledWith('/api/chat', {
                  message: 'Test message',
                  session_id: expect.any(String)
                });
              });
            });

            test('displays chat messages', async () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              
              fireEvent.change(messageInput, { target: { value: 'Hello' } });
              fireEvent.click(sendButton);
              
              await waitFor(() => {
                expect(screen.getByText('Hello')).toBeInTheDocument();
                expect(screen.getByText('Test response')).toBeInTheDocument();
              });
            });

            test('handles API errors gracefully', async () => {
              axios.post.mockRejectedValue(new Error('Network error'));
              
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              
              fireEvent.change(messageInput, { target: { value: 'Test message' } });
              fireEvent.click(sendButton);
              
              await waitFor(() => {
                expect(screen.getByText(/Error: Unable to get response/)).toBeInTheDocument();
              });
            });

            test('handles file drop', () => {
              render(<App />);
              const dropZone = screen.getByText(/Drop files here/i).closest('div');
              
              const file = new File(['test content'], 'test.txt', { type: 'text/plain' });
              const dragEvent = {
                dataTransfer: { files: [file] },
                preventDefault: jest.fn(),
                stopPropagation: jest.fn()
              };
              
              fireEvent.drop(dropZone, dragEvent);
              expect(dragEvent.preventDefault).toHaveBeenCalled();
            });

            test('clears conversation when clear button clicked', async () => {
              axios.delete.mockResolvedValue({ data: { message: 'cleared' } });
              
              // Mock window.confirm
              window.confirm = jest.fn(() => true);
              
              render(<App />);
              const clearButton = screen.getByText(/Clear Chat/i);
              
              fireEvent.click(clearButton);
              
              await waitFor(() => {
                expect(axios.delete).toHaveBeenCalled();
              });
              
              window.confirm.mockRestore();
            });

            test('handles keyboard shortcuts (Enter to send)', () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              
              fireEvent.change(messageInput, { target: { value: 'Test' } });
              fireEvent.keyDown(messageInput, { key: 'Enter', code: 'Enter' });
              
              expect(axios.post).toHaveBeenCalledWith('/api/chat', {
                message: 'Test',
                session_id: expect.any(String)
              });
            });

            test('handles Shift+Enter for new line', () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              
              fireEvent.change(messageInput, { target: { value: 'Test' } });
              fireEvent.keyDown(messageInput, { key: 'Enter', code: 'Enter', shiftKey: true });
              
              // Should not submit form with Shift+Enter
              expect(axios.post).not.toHaveBeenCalled();
            });

            test('displays file upload feedback', async () => {
              const mockUploadResponse = {
                data: { message: 'Success', files: [{ name: 'test.txt' }] }
              };
              axios.post.mockResolvedValue(mockUploadResponse);
              
              render(<App />);
              const fileInput = screen.getByText(/Drop files here/i).closest('div').querySelector('input[type="file"]');
              
              const file = new File(['test'], 'test.txt', { type: 'text/plain' });
              fireEvent.change(fileInput, { target: { files: [file] } });
              
              // Simulate form submission with file
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              fireEvent.click(sendButton);
              
              await waitFor(() => {
                expect(screen.getByText(/Successfully uploaded/)).toBeInTheDocument();
              });
            });
          });

          // Performance and Integration Tests
          describe('App Performance', () => {
            test('component renders within reasonable time', () => {
              const start = Date.now();
              render(<App />);
              const renderTime = Date.now() - start;
              
              expect(renderTime).toBeLessThan(1000); // Should render within 1 second
            });

            test('handles multiple rapid clicks gracefully', async () => {
              render(<App />);
              const messageInput = screen.getByRole('textbox');
              const sendButton = screen.getByRole('button', { name: /ðŸš€/ });
              
              fireEvent.change(messageInput, { target: { value: 'Test' } });
              
              // Rapidly click send button
              fireEvent.click(sendButton);
              fireEvent.click(sendButton);
              fireEvent.click(sendButton);
              
              // Should handle gracefully without errors
              await waitFor(() => {
                expect(axios.post).toHaveBeenCalled();
              });
            });
          });
          EOF

      - name: Run tests with coverage
        run: |
          CI=true npm test -- --coverage --watchAll=false --passWithNoTests --testPathIgnorePatterns=[]
        env:
          CI: true

      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          file: ./frontend/coverage/lcov.info
          flags: frontend
          name: frontend-coverage
          fail_ci_if_error: false

      - name: Upload test artifacts
        uses: actions/upload-artifact@v3
        if: always()
        with:
          name: test-results-${{ env.SERVICE_NAME }}-node${{ matrix.node-version }}
          path: |
            frontend/coverage/
            frontend/test-results.xml

  # Build Application
  build:
    name: Build Application
    runs-on: ubuntu-latest
    needs: [lint, security, test]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: frontend/package-lock.json

      - name: Install dependencies
        run: |
          if [ ! -f "package-lock.json" ]; then
            npm install
          else
            npm ci
          fi

      - name: Build application
        run: |
          npm run build
        env:
          REACT_APP_API_URL: /api
          CI: false

      - name: Test build output
        run: |
          if [ ! -d "build" ] || [ ! -f "build/index.html" ]; then
            echo "âŒ Build failed - missing build directory or index.html"
            exit 1
          fi
          
          echo "âœ… Build completed successfully"
          echo "ðŸ“Š Build statistics:"
          echo "- Build size: $(du -sh build/)"
          echo "- Files created: $(find build/ -type f | wc -l)"
          
          # Check for essential files
          if [ -f "build/static/js/"*.js ]; then
            echo "âœ… JavaScript bundles created"
          else
            echo "âš ï¸ JavaScript bundles not found"
          fi
          
          if [ -f "build/static/css/"*.css ]; then
            echo "âœ… CSS bundles created"
          else
            echo "âš ï¸ CSS bundles not found"
          fi

      - name: Upload build artifacts
        uses: actions/upload-artifact@v3
        with:
          name: build-artifacts-${{ env.SERVICE_NAME }}
          path: frontend/build/
          retention-days: 7

  # Build Docker Image
  docker-build:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: [build]
    if: github.event_name == 'push'
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
      image-digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest,enable={{is_default_branch}}
            type=raw,value=stable,enable={{is_default_branch}}

      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: ./frontend
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha,scope=${{ env.SERVICE_NAME }}
          cache-to: type=gha,mode=max,scope=${{ env.SERVICE_NAME }}
          platforms: linux/amd64,linux/arm64
          build-args: |
            REACT_APP_API_URL=/api

      - name: Generate build summary
        run: |
          echo "## ðŸ³ Docker Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ env.IMAGE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tags**: ${{ steps.meta.outputs.tags }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Digest**: ${{ steps.build.outputs.digest }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Platforms**: linux/amd64, linux/arm64" >> $GITHUB_STEP_SUMMARY

  # Container Security Scan
  container-security:
    name: Container Security Scan
    runs-on: ubuntu-latest
    needs: [docker-build]
    if: github.event_name == 'push'
    
    steps:
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.IMAGE_NAME }}:${{ github.ref_name }}-${{ github.sha }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH,MEDIUM'

      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Trigger CD Pipeline
  trigger-cd:
    name: Trigger CD Pipeline
    runs-on: ubuntu-latest
    needs: [docker-build, container-security]
    if: github.ref == 'refs/heads/main' || github.ref == 'refs/heads/develop'
    
    steps:
      - name: Trigger CD workflow
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const environment = '${{ github.ref }}' === 'refs/heads/main' ? 'production' : 'staging';
            
            await github.rest.actions.createWorkflowDispatch({
              owner: context.repo.owner,
              repo: context.repo.repo,
              workflow_id: 'frontend-cd.yml',
              ref: '${{ github.ref }}',
              inputs: {
                environment: environment,
                image_tag: '${{ github.ref_name }}-${{ github.sha }}'
              }
            });

  # Final Status
  status:
    name: CI Status
    runs-on: ubuntu-latest
    needs: [lint, security, test, build, docker-build, container-security, trigger-cd]
    if: always()
    
    steps:
      - name: Check CI status
        run: |
          echo "## ðŸš€ CI Pipeline Results" >> $GITHUB_STEP_SUMMARY
          echo "- **Lint**: ${{ needs.lint.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Security**: ${{ needs.security.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests**: ${{ needs.test.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Build**: ${{ needs.build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Docker Build**: ${{ needs.docker-build.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Container Security**: ${{ needs.container-security.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- **CD Trigger**: ${{ needs.trigger-cd.result }}" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ needs.lint.result }}" == "success" && "${{ needs.security.result }}" == "success" && "${{ needs.test.result }}" == "success" && "${{ needs.build.result }}" == "success" && "${{ needs.docker-build.result }}" == "success" ]]; then
            echo "âœ… **All CI checks passed!**" >> $GITHUB_STEP_SUMMARY
            exit 0
          else
            echo "âŒ **Some CI checks failed!**" >> $GITHUB_STEP_SUMMARY
            exit 1
          fi
