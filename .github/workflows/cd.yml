# .github/workflows/frontend-cd.yml
name: Frontend - CD

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        type: choice
        options:
        - staging
        - production
      image_tag:
        description: 'Docker image tag to deploy'
        required: true
        type: string
  repository_dispatch:
    types: [deploy-frontend]

env:
  SERVICE_NAME: frontend
  IMAGE_NAME: samitsinghhh/frontend
  KUBE_CONFIG_DATA: ${{ secrets.KUBE_CONFIG_DATA }}

jobs:
  deploy:
    name: Deploy to Kubernetes
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment || github.event.client_payload.environment || 'staging' }}
    
    steps:
      - name: Set deployment parameters
        id: params
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
            IMAGE_TAG="${{ github.event.inputs.image_tag }}"
          elif [ "${{ github.event_name }}" = "repository_dispatch" ]; then
            ENVIRONMENT="${{ github.event.client_payload.environment }}"
            IMAGE_TAG="${{ github.event.client_payload.image_tag }}"
          else
            ENVIRONMENT="staging"
            IMAGE_TAG="latest"
          fi
          
          if [ "$ENVIRONMENT" = "production" ]; then
            NAMESPACE="bedrock-chat-v2"
          else
            NAMESPACE="bedrock-chat-staging"
          fi
          
          echo "environment=$ENVIRONMENT" >> $GITHUB_OUTPUT
          echo "namespace=$NAMESPACE" >> $GITHUB_OUTPUT
          echo "image_tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "full_image=${{ env.IMAGE_NAME }}:$IMAGE_TAG" >> $GITHUB_OUTPUT
          
          echo "üöÄ Deployment Configuration:"
          echo "- Environment: $ENVIRONMENT"
          echo "- Namespace: $NAMESPACE"
          echo "- Image Tag: $IMAGE_TAG"
          echo "- Full Image: ${{ env.IMAGE_NAME }}:$IMAGE_TAG"

      - name: Checkout k8s manifests
        uses: actions/checkout@v4
        with:
          repository: ${{ github.repository_owner }}/k8s-manifests
          token: ${{ secrets.MANIFEST_REPO_TOKEN }}
          path: k8s-manifests

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          if [ -z "${{ env.KUBE_CONFIG_DATA }}" ]; then
            echo "‚ùå KUBE_CONFIG_DATA secret not found!"
            exit 1
          fi
          
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          chmod 600 kubeconfig
          
          kubectl cluster-info --request-timeout=30s
          echo "‚úÖ Connected to Kubernetes cluster"

      - name: Update deployment manifest
        run: |
          cd k8s-manifests
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/frontend-deployment.yaml"
            "deployments/frontend-deployment.yaml"
            "manifests/frontend-deployment.yaml"
          )
          
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DEPLOYMENT_FILE="$path"
              echo "Found deployment file: $path"
              break
            fi
          done
          
          if [ -z "$DEPLOYMENT_FILE" ]; then
            echo "‚ùå Frontend deployment file not found!"
            echo "Available files:"
            find . -name "*frontend*.yaml" -type f || echo "No Frontend files found"
            exit 1
          fi
          
          echo "üìù Updating image in $DEPLOYMENT_FILE"
          echo "From: $(grep -n "image:" "$DEPLOYMENT_FILE" | head -1)"
          
          # Update image tag
          sed -i "s|image: samitsinghhh/frontend:.*|image: ${{ steps.params.outputs.full_image }}|g" "$DEPLOYMENT_FILE"
          
          echo "To: $(grep -n "image:" "$DEPLOYMENT_FILE" | head -1)"
          echo "‚úÖ Manifest updated successfully"

      - name: Create namespace
        run: |
          export KUBECONFIG=kubeconfig
          kubectl create namespace ${{ steps.params.outputs.namespace }} --dry-run=client -o yaml | kubectl apply -f -
          echo "‚úÖ Namespace ready: ${{ steps.params.outputs.namespace }}"

      - name: Apply supporting resources
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          # Apply ConfigMaps
          if [ -d "k8s/configmaps" ]; then
            echo "üìã Applying ConfigMaps..."
            kubectl apply -f k8s/configmaps/ -n ${{ steps.params.outputs.namespace }} || true
          fi
          
          # Apply Frontend Services
          echo "üåê Applying Frontend Services..."
          if [ -f "k8s/services/frontend-service.yaml" ]; then
            kubectl apply -f k8s/services/frontend-service.yaml -n ${{ steps.params.outputs.namespace }} || true
          fi
          
          # Apply NodePort service if exists (for direct access)
          if [ -f "k8s/services/frontend-nodeport.yaml" ]; then
            echo "üîó Applying Frontend NodePort service..."
            kubectl apply -f k8s/services/frontend-nodeport.yaml -n ${{ steps.params.outputs.namespace }} || true
          fi

      - name: Deploy Frontend
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          echo "üöÄ Deploying Frontend..."
          
          DEPLOYMENT_FILE=""
          POSSIBLE_PATHS=(
            "k8s/deployments/frontend-deployment.yaml"
            "deployments/frontend-deployment.yaml"
            "manifests/frontend-deployment.yaml"
          )
          
          for path in "${POSSIBLE_PATHS[@]}"; do
            if [ -f "$path" ]; then
              DEPLOYMENT_FILE="$path"
              break
            fi
          done
          
          kubectl apply -f "$DEPLOYMENT_FILE" -n ${{ steps.params.outputs.namespace }}
          
          echo "‚è≥ Waiting for rollout to complete..."
          kubectl rollout status deployment/frontend -n ${{ steps.params.outputs.namespace }} --timeout=300s

      - name: Verify deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîç Verifying deployment..."
          
          # Check deployment status
          kubectl get deployment frontend -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check pods
          echo "=== Pod Status ==="
          kubectl get pods -l app=frontend -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Check services
          echo "=== Service Status ==="
          kubectl get services -l app=frontend -n ${{ steps.params.outputs.namespace }} -o wide
          
          # Wait for pod to be ready
          kubectl wait --for=condition=ready pod -l app=frontend -n ${{ steps.params.outputs.namespace }} --timeout=120s

      - name: Run health checks
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üè• Running health checks..."
          
          # Test health endpoint
          echo "Testing health endpoint..."
          if kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/frontend -- wget -qO- --timeout=10 http://localhost:3000/health; then
            echo "‚úÖ Health check passed"
          else
            echo "‚ö†Ô∏è Health check failed, checking logs..."
            kubectl logs -n ${{ steps.params.outputs.namespace }} deployment/frontend --tail=20
            echo "‚ö†Ô∏è Continuing deployment despite health check failure..."
          fi

      - name: Test frontend accessibility
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üåê Testing frontend accessibility..."
          
          # Test root endpoint
          echo "Testing root endpoint..."
          if kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/frontend -- wget -qO- --timeout=10 http://localhost:3000/ > /dev/null; then
            echo "‚úÖ Frontend root endpoint accessible"
          else
            echo "‚ö†Ô∏è Frontend root endpoint test failed"
            kubectl logs -n ${{ steps.params.outputs.namespace }} deployment/frontend --tail=10
          fi
          
          # Test API proxy (if configured)
          echo "Testing API proxy configuration..."
          if kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/frontend -- wget -qO- --timeout=5 http://localhost:3000/api/ > /dev/null 2>&1; then
            echo "‚úÖ API proxy configuration working"
          else
            echo "‚ö†Ô∏è API proxy test failed (this may be expected if API Gateway is not deployed)"
          fi

      - name: Apply ingress (production)
        if: steps.params.outputs.environment == 'production'
        run: |
          export KUBECONFIG=kubeconfig
          cd k8s-manifests
          
          if [ -f "k8s/ingress/bedrock-chat-ingress.yaml" ]; then
            echo "üåç Applying production ingress..."
            kubectl apply -f k8s/ingress/bedrock-chat-ingress.yaml -n ${{ steps.params.outputs.namespace }}
            
            echo "‚è≥ Waiting for ingress to be ready..."
            sleep 30
            
            echo "=== Ingress Status ==="
            kubectl get ingress -n ${{ steps.params.outputs.namespace }} -o wide
            
            # Show ingress details
            kubectl describe ingress bedrock-chat-ingress -n ${{ steps.params.outputs.namespace }} || true
          else
            echo "‚ö†Ô∏è Production ingress file not found"
          fi

      - name: Run smoke tests
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üß™ Running smoke tests..."
          
          # Test static assets loading
          echo "Testing static assets..."
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/frontend -- ls -la /usr/share/nginx/html/static/ || echo "Static assets check failed"
          
          # Test nginx configuration
          echo "Testing nginx configuration..."
          kubectl exec -n ${{ steps.params.outputs.namespace }} deployment/frontend -- nginx -t || echo "Nginx config test failed"
          
          # Test service connectivity within cluster
          echo "Testing service connectivity..."
          if kubectl run test-pod --image=curlimages/curl --rm -i --restart=Never -n ${{ steps.params.outputs.namespace }} -- curl -f http://frontend:3000/health --max-time 10; then
            echo "‚úÖ Service connectivity test passed"
          else
            echo "‚ö†Ô∏è Service connectivity test failed"
          fi
          
          echo "‚úÖ Smoke tests completed"

      - name: Check external access (production)
        if: steps.params.outputs.environment == 'production'
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "üîó Checking external access..."
          
          # Get ingress information
          INGRESS_IP=$(kubectl get ingress bedrock-chat-ingress -n ${{ steps.params.outputs.namespace }} -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
          INGRESS_HOST=$(kubectl get ingress bedrock-chat-ingress -n ${{ steps.params.outputs.namespace }} -o jsonpath='{.spec.rules[0].host}' 2>/dev/null || echo "")
          
          if [ -n "$INGRESS_IP" ]; then
            echo "üìç Ingress IP: $INGRESS_IP"
          fi
          
          if [ -n "$INGRESS_HOST" ]; then
            echo "üåê Ingress Host: $INGRESS_HOST"
          fi
          
          # Get NodePort information (if available)
          NODE_PORT=$(kubectl get service frontend-nodeport -n ${{ steps.params.outputs.namespace }} -o jsonpath='{.spec.ports[0].nodePort}' 2>/dev/null || echo "")
          if [ -n "$NODE_PORT" ]; then
            echo "üîó NodePort: $NODE_PORT"
          fi

      - name: Deployment summary
        if: always()
        run: |
          export KUBECONFIG=kubeconfig
          
          echo "## üöÄ Frontend Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${{ env.SERVICE_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ steps.params.outputs.environment }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Namespace**: ${{ steps.params.outputs.namespace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: ${{ steps.params.outputs.full_image }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" = "success" ]; then
            echo "‚úÖ **Deployment successful!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üìä Deployment Status" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get pods -l app=frontend -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üåê Access Information" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get services -l app=frontend -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            if [ "${{ steps.params.outputs.environment }}" = "production" ]; then
              echo "" >> $GITHUB_STEP_SUMMARY
              kubectl get ingress -n ${{ steps.params.outputs.namespace }} >> $GITHUB_STEP_SUMMARY 2>&1 || true
            fi
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          else
            echo "‚ùå **Deployment failed!**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### üîç Troubleshooting Info" >> $GITHUB_STEP_SUMMARY
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
            kubectl get events -n ${{ steps.params.outputs.namespace }} --sort-by='.lastTimestamp' | tail -10 >> $GITHUB_STEP_SUMMARY 2>&1 || true
            echo "\`\`\`" >> $GITHUB_STEP_SUMMARY
          fi

  # Rollback capability
  rollback:
    name: Rollback (Manual)
    runs-on: ubuntu-latest
    if: failure() && github.event.inputs.environment
    environment: ${{ github.event.inputs.environment }}
    
    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: 'v1.28.0'

      - name: Configure kubectl
        run: |
          echo "${{ env.KUBE_CONFIG_DATA }}" | base64 -d > kubeconfig
          export KUBECONFIG=kubeconfig
          chmod 600 kubeconfig

      - name: Rollback deployment
        run: |
          export KUBECONFIG=kubeconfig
          
          NAMESPACE="${{ github.event.inputs.environment == 'production' && 'bedrock-chat-v2' || 'bedrock-chat-staging' }}"
          
          echo "üîÑ Rolling back Frontend deployment..."
          kubectl rollout undo deployment/frontend -n $NAMESPACE
          
          echo "‚è≥ Waiting for rollback to complete..."
          kubectl rollout status deployment/frontend -n $NAMESPACE --timeout=180s
          
          echo "‚úÖ Rollback completed"
